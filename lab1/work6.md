### 练习 6：完善中断初始化和处理 （需要编程）
#### 请完成编码工作和回答如下问题：

中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？  

> 请编程完善 kern/trap/trap.c 中对中断向量表进行初始化的函数 idt_init。在 idt_init 函数中，依次对所有中断入口进行初始化。使用 mmu.h 中的 SETGATE 宏，填充 idt 数组内容。每个中断的入口由 tools/vectors.c 生成，使用 trap.c 中声明的 vectors 数组即可。  

请编程完善 trap.c 中的中断处理函数 trap，在对时钟中断进行处理的部分填写 trap 函数中处理时钟中断的部分，使操作系统每遇到 100 次时钟中断后，调用 print_ticks 子程序，向屏幕上打印一行文字”100 ticks”。  

**【注意】**除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而 ucore 的应用程序处于特权级３，需要采用｀ int 0x80`指令操作（这种方式称为软中断，软件中断，Tra 中断，在 lab5 会碰到）来发出系统调用请求，并要能实现从特权级３到特权级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）需要设置为３。  

要求完成问题 2 和问题 3 提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对问题 1 的回答。完成这问题 2 和 3 要求的部分代码后，运行整个系统，可以看到大约每 1 秒会输出一次”100 ticks”，而按下的键也会在屏幕上显示。  

#### 提示：可阅读小节“中断与异常”。

----
**1. 中断与异常**  

> 操作系统需要对计算机系统中的各种外设进行管理，这就需要 CPU 和外设能够相互通信才行。一般外设的速度远慢于 CPU 的速度。如果让操作系统通过 CPU“主动关心”外设的事件，即采用通常的轮询(polling)机制，则太浪费 CPU 资源了。所以需要操作系统和 CPU 能够一起提供某种机制，让外设在需要操作系统处理外设相关事件的时候，能够“主动通知”操作系统，即打断操作系统和应用的正常执行，让操作系统完成外设的相关处理，然后在恢复操作系统和应用的正常执行。在操作系统中，这种机制称为中断机制。中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。  

在操作系统中，有三种特殊的中断事件。
- 由 CPU 外部设备引起的外部事件如 I/O 中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），**与 CPU 的执行无关**，我们称之为**异步中断(asynchronous interrupt)也称外部中断,简称中断(interrupt)。**  

- 而把在 CPU 执行指令期间**检测到不正常的或非法的条件**(如除零错、地址访问越界)所引起的内部事件称作**同步中断(synchronous interrupt)，也称内部中断，简称异常(exception)**。  

- 把在**程序中使用请求系统服务的系统调用**而引发的事件，称作**陷入中断(trap interrupt)，也称软中断(soft interrupt)，系统调用(system call)简称 trap**。在后续试验中会进一步讲解系统调用。  

本实验只描述保护模式下的处理过程。当 CPU 收到中断（通过 8259A 完成，有关 8259A 的信息请看附录 A）或者异常的事件时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理例程中，在完成对这个事件的处理后再跳回到刚才被打断的程序或任务中。  
#### 中断向量和中断服务例程的对应关系主要是由 IDT（中断描述符表 ）负责。  
#### 操作系统在 IDT 中设置好各种中断向量对应的中断描述符，待 CPU 在产生中断后查询对应中断服务例程的起始地址。而 IDT 本身的起始地址保存在 idtr 寄存器中。
(1) 中断描述符表（Interrupt Descriptor Table） 中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同 GDT 一样，IDT 是一个 8 字节的描述符数组，但 IDT 的第一项可以包含一个描述符。CPU 把中断（异常）号乘以 8 做为 IDT 的索引。IDT 可以位于内存的任意位置，CPU 通过 IDT 寄存器（IDTR）的内容来寻址 IDT 的起始地址。指令 LIDT 和 SIDT 用来操作 IDTR。**两条指令都有一个显示的操作数：一个 6 字节表示的内存地址；48位，高32位是IDT的基地址，低16位是IDT的界限。**  
> LIDT 和 SIDT 指令分别用来装载和保存 IDTR寄存器 的值。 LIDT 指令使用包含基址和限长的内
存操作数装载 IDTR寄存器。该指令只有当 CPL 为0时才能使用。通常在操作系统的初始化代
码中创建IDT时才被用到。 SIDT 指令将 IDTR寄存器 中的基址和限长保存到内存操作数中。可在任何特权级上使用。  
**PS :** 内存操作数：指令要操作的数据存放在内存某些单元中，指令中给出内存单元物理地址（实际上指令只给出了偏移地址，段地址采用隐含方式给出，也可以使用跨段方式指出当前段地址）。  

指令的含义如下：

- LIDT（Load IDT Register）指令：使用一个包含线性地址基址和界限的内存操作数来加载 IDT。操作系统创建 IDT 时需要执行它来设定 IDT 的起始地址。这条指令只能在特权级 0 执行。（可参见 libs/x86.h 中的 lidt 函数实现，其实就是一条汇编指令）  
- SIDT（Store IDT Register）指令：拷贝 IDTR 的基址和界限部分到一个内存地址。这条指令可以在任意特权级执行。  

在保护模式下，最多会存在 256 个 Interrupt/Exception Vectors。范围[0，31]内的 32 个向量被异常 Exception 和 NMI 使用，但当前并非所有这 32 个向量都已经被使用，有几个当前没有被使用的，请不要擅自使用它们，它们被保留，以备将来可能增加新的 Exception。范围[32，255]内的向量被保留给用户定义的 Interrupts。Intel 没有定义，也没有保留这些 Interrupts。用户可以将它们用作外部 I/O 设备中断（8259A IRQ），或者系统调用（System Call 、Software Interrupts）等。  

----
**2. 中断与异常的处理**  

#### 2.1 描述   
LIDT给出中断门描述表的地址和他的界限。通过中断号，和基地址可以找到我要调用哪一个中断描述符。表中每一个描述符占64位，8字节。有三类：任务门描述符、中断门描述符、陷阱门描述符。（具体可以看IA32卷3）或者：https://learningos.github.io/ucore_os_webdocs/lab1/lab1_3_3_2_interrupt_exception.html  
- 注意，**当调用 Interrupt Gate 时，Interrupt 会被 CPU 自动禁止**；而调用 Trap Gate 时，CPU 则不会去禁止或打开中断，而是保留它原来的样子。  

- > 【补充】  
所谓“自动禁止”，**指的是 CPU 跳转到 interrupt gate 里的地址时，在将 EFLAGS 保存到栈上之后，清除 EFLAGS 里的 IF 位，以避免重复触发中断。**在中断处理例程里，操作系统可以将 EFLAGS 里的 IF 设上,从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。  
在 ucore 中访问 Trap Gate 的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过 Trap Gate 完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的 OS kernel。  
如果在到达 OS kernel 后禁止 EFLAGS 里的 IF 位，第一没意义（因为不会出现嵌套系统调用的情况）；第二还会导致某些中断得不到及时响应。所以调用 Trap Gate 时，CPU 则不会去禁止中断。总之，interrupt gate 和 trap gate 之间没有优先级之分，仅仅是 CPU 在处理中断时有不同的方法，供操作系统在实现时 根据需要进行选择。

**中断描述符中一般保存了段选择子和偏移量，可以找到对应处理函数的地址。**  
#### 2.1 中断时堆栈变化过程  
中断门或陷阱门引用一个异常或中断处理例程，这个例程可能运行于当前执行任务的上下文中。门中的段选择符指向位于GDT的可执行代码段的段描述符。 

当处理器转去执行一个异常或中断处理例程时， 会将 EFLAGS 寄存器， CS 寄存器， EIP 寄存
器的当前值保存进栈。(CS 和 EIP 寄存器为中断提供了一个返回地址指针。)如果异常同时产生了一个出错码，则该值也会压入栈中，位于 EIP 之后。  

如果处理例程和被中断的进程处于同一特权级，则处理例程使用当前堆栈。  
若当处理例程将运行于更高一级的特权级上时，堆栈发生切换。这时，指向返回后使用的
栈指针也被压入栈中。 (SS 和 ESP 用作处理例程返回后的栈指针)。  
**而处理例程要使用的堆栈段选择符和栈指针则从当前进程的 TSS 中得到。** 处理器将 EFLAGS，SS，ESP，CS，EIP，还有出错码从当前进程的堆栈拷贝到处理例程的堆栈。 

从例程处返回，必须使用 IRET/IRETD 指令；和一般的返回指令 RET 不同；IRET 中断返回指令还会恢复标志位。  
> **PS ：** IRET 指令  
将程序控制权 从异常或中断处理程序 返回 异常、外部中断或软件生成的中断 **所中断的程序** 。这些指令也用于执行从嵌套任务的返回。（使用 CALL 指令启动任务切换时，或是中断、异常导致任务切换到中断或异常程序时，都会创建嵌套任务）。  
IRET 与 IRETD 是相同操作码的助记符。IRETD 助记符（中断返回双字）用于从使用 32 位操作数大小的中断返回；不过大多数汇编器对这两种操作数大小都互换使用 IRET 助记符。 

- 根据处理器的操作模式，可能会修改 EFLAGS 寄存器中的所有标志与字段。如果执行从嵌套任务到前一项任务的返回，则根据前一项任务的 TSS 存储的 EFLAGS 映像修改 EFLAGS 寄存器。  

参考：https://segmentfault.com/a/1190000009552351 这里面讲述了中断信号发生后会做什么，包括特权级转换的检测和内核栈的变化。  
总结一下就是：  
1. CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量；
2. CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子；
3. CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，并立即将系统当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；
4. CPU需要保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；
5. CPU使用IDT查到的中断服务例程的段选择子从GDT中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址，并跳转到该地址；
6. CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务例程。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。  
- 这两种情况都需要压入CS，EIP和Error Code(如果有的话)。之所以我说第5步应该在第4步后，原因就在这里，如果先跳到了中断服务例程（ISR），那么压入的EIP就是ISR中的EIP了，并不是中断前的EIP，因此我们应该在第5步前完成步骤3和4。  
![g](https://segmentfault.com/img/remote/1460000009552356)

